% !TEX encoding = UTF-8 Unicode
\documentclass[11pt]{article} % use larger type; default would be 10pt

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....


%%% PACKAGES
\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{subfiles}
\usepackage{amssymb}
\usepackage{tabulary}
\usepackage{color, colortbl}
\usepackage{xcolor}


\usepackage{graphicx, wrapfig} % support the \includegraphics command and options

\DeclareGraphicsExtensions{.png,.jpg}
\graphicspath{{img/}{../img/}}
\usepackage{gensymb}
\usepackage{pdfpages}
\usepackage{standalone}
\usepackage{float}
\usepackage[toc,page]{appendix}

%%% Codes
\usepackage{listings}
\definecolor{Gray}{gray}{0.9}
\setlength{\parindent}{0em} 

\usepackage[breaklinks=true]{hyperref}


%%% HEADERS & FOOTERS
\usepackage{fancyhdr}	% This should be set AFTER setting up the page geometry
\pagestyle{fancy}	% options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt}	% customise te layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% END Article customizations

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        
        \Huge
        \textbf{WODSS}
        
        \vspace{0.5cm}
        \LARGE
        Event Planner
      
        \vspace{1.5cm}
        
        \textbf{Autoren: Andreas Gassmann, Jonas Frehner, Lukas Schönbächler}\\

		\vspace{1.5cm}        
                
        \vfill
        
       
        \vspace{0.8cm}
        
        \includegraphics[width=0.4\textwidth]{title/fhnw}
        
        \Large
        FHNW\\
        Schweiz\\
        März 27, 2017
        
    \end{center}
\end{titlepage}

\begin{abstract}
Das vorliegende Projekt wurde im Rahmen des Moduls "wodss" der FHNW realisiert. Es wurde eine Plattform entwickelt, mit deren Hilfe auf einfache Art und Weise CS-Seminare und Anmeldungen zu den entsprechenden Anlässen verwaltet werden können.
Die Lösung wurde mit Hilfe von Angular2 und Ionic im Frontend und SpringBoot im Backend realisiert. Architektonisch basiert das Projekt auf der Serverseite auf so genannten Microservices.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Mockups}
\subsection{Login}
\includegraphics[width=1\textwidth]{prototyp/Login}

\subsection{Übersicht}
\includegraphics[width=1\textwidth]{prototyp/Vortragansicht}
\includegraphics[width=1\textwidth]{prototyp/ExternePersonen}

\subsection{Detailansicht}
\includegraphics[width=1\textwidth]{prototyp/Einladungen}

\subsection{Einschreiben}
\includegraphics[width=1\textwidth]{prototyp/Vortrag}

\newpage
\section{Architektur - Backend}
Wie bereits in der Einleitung erwähnt, implementierten wir dieses Projekt als Microservices. Wir verwenden dazu "Eureka", eine von Netflix entwickelte Library (siehe auch: https://github.com/netflix/eureka). Die Applikation lässt sich in fünf Microservices unterteilen, welche im nachfolgenden Abschnitt genauer beschrieben werden. Die Microservices kommunizieren per REST untereinander.

\subsection{Schichtenarchitektur}
\subsubsection{Webschicht}
Die Webschicht wird automatisch durch den RepositoryRestResource bereitgestellt. Das heisst, die betreffenden RepositoryRestResourcen stellen automatisch die so annotierten JPA-Entitäten via REST-Schnittstelle bereit.

\subsubsection{Businesschicht}
Da das vorliegende Projekt eine relativ einfache Business-Schicht aufweist (vielfach handelt es sich um einfache GET/POST/PUT/DELETE auf bestehenden Entitäten), wird diese ebenfalls von den RepositoryRestResourcen wahrgenommen.
Wo eine etwas ausgefeilterte Logik notwendig war (z.B. beim Login oder bei der Passwort-Zurücksetzen-Funktionalität) wurden eigene RestController erstellt (wie beispielsweise das LoginRepository).

\subsubsection{Datenbankschicht}
Die Datenbankschicht wurde mit Hilfe von JPA-Repositories realisiert. Für eine genauere Diskussion zum Aufbau der Persistenzschicht siehe unterkapitel Datenbank.

\subsection{Microservices}
\subsubsection{Registry}
Die Registry stellt das "Bindeglied" zwischen den verschiedenen Microservices dar. Die Microservices verbinden sich auf die Registry um dort die URLs der anderen Microservices zu bekommen. Dadurch wird es möglich die Applikation auf mehreren Servern verteilt laufen zu lassen. Im Falle einer bestehenden Eureka Installation/Architektur muss dieser Microservice nicht nochmals zusätzlich gestartet werden (bestehende Registry kann verwendet werden).
Durch die Verwendung des "Loadbalanced" RestTemplates lösen Microservices die logischen Namen anderer Microservices selbstständig mit Rückgriff auf die Registry zu korrekten IP-Adressen auf.

\subsubsection{Eventmanagement}
Der Microservice Eventmanagement ist der zentrale Service unserer Applikation. Er beinhaltet die Persistenzschicht mit allen Entitäten, sowie die Businesslogik der Anwendung. Zudem werden alle Zugriffe auf die Daten und die Logik via diesem Service getätigt. Hierfür werden die CRUD Operationen über eine REST-API zur Verfügung gestellt (mittels den oben erwähnten RepositoryRestResource-Controllern). Bestimmte Endpunkte stehen dabei nur nach erfolgreicher Authentifizierung und Autorisierung zur Verfügung. Die komplette Schnittstellendokumentation ist im Anhang (Swagger Schnittstellendokumentation) aufgeführt.

\subsubsection{Frontend}
Dieser Microservice stellt nur einen Container bereit, der dazu dient, statische Inhalte wie HTML-/CSS-Files, Bilder und so weiter zur Verfügung zu stellen. Er enthält keinerlei Business-Logik und speichert keine Benutzerdaten. Konkret wird der Build Folder unserer Ionic-App in den assets/static Order kopiert. Sollte bereits eine bestehende Webserver Infrastruktur zur Verfügung stehen (z.B. Apache oder Nginx), können diese Assets auch ohne zusätzlichen Microservice gehostet werden.

\subsubsection{Mailer}
Der Mailer ist ein simpler Mailservice, welcher eine API zum Versenden von Mails bietet. Diese API wird durch ein statisches Token geschützt, das alle Aufrufer mitschicken müssen, um Mails versenden zu können. Da der Token nur intern (via application.properties-Files der entsprechenden Microservices) bekannt ist, werden ausschliesslich interne (von anderen Microservices) Anfragen entgegengenommen.

\subsubsection{Scheduler}
Der Scheduler Service führt zu bestimmten Zeiten verschiedene Tasks aus. Ein Beispiel hierfür wäre, unreferenzierte  Mediendateien in der Nacht zu löschen, Erinnerungsmails zu versenden oder Events aufgrund verschiedener Kriterien zu archivieren.

\newpage
\subsection{Sicherheit}


\newpage
\subsection{Datenbank}
Um für die Datenintegrität garantieren zu können, werden alle Entitäten wie oben durch einen einzigen Microservice verwaltet (https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/).

\includegraphics[width=1\textwidth]{dbSchema}
\newpage
\section{Architektur - Frontend}
\subsection{Ionic}
Pages usw.

\newpage
\section{Projektaufbau - Backend}
Für alle Microservices wurde jeweils ein eigenes Sub-Projekt erstellt, die jeweils aus einem build-, gradle- und src-Ordner bestehen. Für jeden Microservice existiert ein eigenes build.gradle, das die Projektspezifischen Abhängigkeiten enthält.
Der Root-Folder enthält alle Microservices, sowie ein Ordner "ionic", der allen Frontend-Code enthält.
\\
Zudem haben wir vier verschiedene .sh-Files erstellt, mit denen die vier Microservices Eventmanagement, Registry, Mailer und Scheduler je einzeln gestartet werden können. Dazu ein .sh-File mit dem alle erwähnten Services zusammen gestartet (run.sh) werden können, gestoppt werden können (kill.sh) oder gestoppt und gleich neu gestartet werden können (restart.sh).
\\
Nachfolgend gehen wir kurz auf den internen Aufbau der einzelnen Microservices ein. Dabei werden wir nur den Aufbau des src-Ordners präsentieren, da sich der Build- und Gradle-Ornder jeweils sehr ähnlich zeigen. Zusätzlich werden auch die relevanten Klassen-Diagramme (in UML) pro Microservice präsentiert.

\subsection{Registry}
Die Registry hat folgende sehr simple Projektstruktur:
\\
\\
\includegraphics[scale=0.7]{structure_registry}
\\
Der Grund für die schlanke Struktur liegt auf der Hand: da sich die Verwendung der Eureka-Library in diesem Projekt grösstenteils auf Annotationen beschränkt besteht die Registry nur aus einer einzigen Klasse, die mittels "EnableEurekaServer" und "SpringBootApplication" annotiert wurde. Die restlichen Microservices verwenden als Klienten die Annotation "EnableDiscoveryClient".

\subsection{Eventmanagement}
Dieser Microservice ist der komplexeste der fünf. Die grobe Struktur präsentiert sich wie folgt:
\\
\\
\includegraphics[scale=0.7]{structure_eventmanagement}
\\
Die Swagger-Configuration-Klasse übernimmt, wie der Name erahnen lässt, die Konfiguration der Swagger-Dokumentation der REST-Schnittstelle. Die Klasse Eventmanagement-Application dient der Initialisierung des Microservices. Nachfolgend werden alle Ordner kurz präsentiert und deren Inhalt etwas genauer beschrieben.
\\
\subsubsection{Endpoints}
Im Folder "endpoints" sind alle Interfaces und Klassen enthalten, die entweder mittels RepositoryRestResource (sofern die Klasse auf einer konkreten JPA-Entität basiert) oder RestController (sofern die Klasse zusätzliche Geschäftslogik bereitstellt) annotiert sind. Die Struktur sieht folgendermassen aus:
\\
\\
\includegraphics[scale=0.7]{structure_eventmanagement_endpoints}
\\
Relativ schnell erkennt man die zusätzliche Geschäftslogik, die zusätzlich zu den RepositoryRestResource-Controllern programmiert wurde und die nicht durch reine Datenzugriffe verarbeitet werden konnten:
\begin{enumerate}
\item AAI-Repository - verarbeitet Login via Switch-AAI
\item FileRepository - bietet Methoden zum Fileupload und -display
\item LoginRepository - bietet Methoden zum Login und zurücksetzen von Passwörtern
\item MailerRepository - bietet Methoden zum Versenden von Einladungmails
\item PrintRepository - bietet Methoden zum Zugriff auf Druckgerecht-aufbereitete Daten
\end{enumerate}
\\
Die restlichen Interfaces beinhalten zum einen die vom JPA-Repository zur Verfügung gestellten Methoden für den Datenzugriff. Zusätzlich dazu wurden, je nach Bedarf, weitere Methoden für die Datenmanipulation erstellt.
\subsubsection{Entities}
Der Ordner "entities" präsentiert sich wie folgt:
\\
\\
\includegraphics[scale=0.7]{structure_eventmanagement_entities}
\\
Dieser Ordner enthält die tatsächlichen JPA-Entitäten, die schlussendlich in der Datenbank als konkrete Tabellen auftauchen (dazu kommen weitere von JPA erstellte Tabellen wie z.B. "Speakers", siehe dazu auch das Kapitel über die Datenkbank). Die Entitäten definieren gemäss JPA die verschiedenen Attribute der jeweiligen Objekte.
\subsubsection{Models}
Der Folder "model" enhält alle weiteren Objekte, die für das Funktionieren der Applikation notwendig sind, aber nicht persistiert werden sollen:
\\
\\
\includegraphics[scale=0.7]{structure_eventmanagement_models}
\\
Eine kurze nähere Beschreibung der verschiedenen Models:
\begin{enumerate}
\item AnwerWrapper
\item EventAttendeeFlat
\item Mail
\item ResetPasswordAnswerMessage
\item ResetPasswordWrapper
\item SecurePath
\end{enumerate}
\subsubsection{Security}
Der Ordner "security" schlussendlich hat folgenden Inhalt:
\\
\\
\includegraphics[scale=0.7]{structure_eventmanagement_security}
\\
\subsection{Frontend}
Frontent:
\\
\\
\includegraphics[scale=0.7]{structure_frontend}
\\
\subsection{Mailer}
Mailer:
\\
\\
\includegraphics[scale=0.7]{structure_mailer}
\\
\subsection{Scheduler}
Scheduler:
\\
\\
\includegraphics[scale=0.7]{structure_scheduler}
\\

\newpage
\section{Projektaufbau - Frontend}

\newpage
\section{Technologien}

\subsection{Frontend}
Nach dem Start mit Angular 2 merkten wir schnell, das uns einige Standardkomponenten fehlten. Außerdem war der Aufwand die Seite Mobile tauglich zu machen größer als erwartet. Aus diesem Grund wechselten wir nach kurzer Zeit auf Ionic 2. Da Ionic 2 auf Angular 2 aufbaut, war der Wechsel schnell vonstatten gegangen. Mithilfe der neuen Sidemenu Komponente kann die Webseite ohne weitere Probleme für Desktops optimiert werden.

\subsection{Backend}
Wie von der Projektbeschreibung vorgeschrieben, verwenden wir Java mit Spring Boot im Backend. Zusätzlich verwenden wir die spring-boot-data Erweiterung, welche uns das einfache erstellen von Rest Repositories ermöglicht. 

\subsubsection{Authentifizierung und Autorisierung}
Für die Authentifizierung verwenden wir PAC4J und verwenden das JWT (Json Web Token). Zusätzlich können mithilfe von PAC4J Permissions und Rollen definiert werden. Abhängig von der Rolle, erhält der Benutzer zusätzliche Privilegien. Ein normaler Besucher kann lediglich Events ansehen und nichts editieren. Wir haben folgende Rollen identifiziert:

\begin{enumerate}
\item Besucher
\item Angemeldeter Gast (kann sich zusätzlich einschreiben)
\item Referent (kann zusätzlich den eigenen Event bearbeiten und Dateien anhängen)
\item Koordinator (kann alle Entitäten bearbeiten und löschen)
\end{enumerate}

\newpage
\section{Design-Entscheide}
Anfangs wollten verschiedene neue Technologien wie z.B. Elm, GraphQL und Microservices testen. Es stellte sich aber schnell heraus, dass es dabei einige Probleme gibt, welche im folgenden Abschnitt erläutert werden.

\begin{enumerate}
\item Elm\\
Elm ist eine relativ neue funktionale Sprache, die zu Javascript kompiliert. Der grosse Vorteil von Elm sind die Typsicherheit sowie der funktionale Aspekt. Es sollte dadurch beispielsweise keine Runtime-Fehler, die in Javascript an der tagesordnung sind, mehr geben.
Es hat sich aber herausgestellt, dass das Ökosystem zwar bereits viele Funktionen bietet, wenn man aber genaue Anforderungen hat muss man teilweise Kompormisse eingehen.
Weiter wird user Projekt durch die Wahl einer "neuen" Programmiersprache weniger wartbar.
\item GraphQL\\
Durch die JPA-GraphQL ist das initiale Aufsetzen eines GraphQL Endpoints nach einigen Versuchen relativ gut gegangen. Leider fehlen der Library aber noch einige zentrale Features, weshalb man nicht komplett auf die REST-API hätte verzichten können. Anstelle von zwei verschiedenen Endpunkten haben wir uns schlussendlich aus gründen der Wartbarkeit für REST entschieden.
\end{enumerate}

\newpage
\section{Lessons learned}
Im Laufe unseres Projekts wurden wir mit einigen Problemen konfrontiert, die insgesamt einen grossen Teil unserer Zeit in Anspruch genommen haben.

\begin{enumerate}
\item Microservices\\
\item Pac4J\\
\item Angular\\
Angular Material2 noch nicht ready, Ionic mehrheitlich ohne Probleme
\item ResourceRestController
\end{enumerate}

\newpage
\begin{appendices}

\textbf{Swagger Schnittstellendokumentation}\\
\url{https://htmlpreview.github.io/?https://raw.githubusercontent.com/lukeisontheroad/simple_event_planner/master/docs/doc.html}\\

\textbf{Github Repository}\\
\url{https://github.com/lukeisontheroad/simple_event_planner}\\

\textbf{Microservices best practices}\\
\url{https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/}\\

\textbf{PAC4J}\\
\url{http://www.pac4j.org/}\\



\newpage

\end{appendices}

\end{document}
